type: edu
files:
  - name: src/metro/Main.java
    visible: true
    text: |
      package metro;
      
      public class Main {
          public static void main(String[] args) {
              System.out.println("Hello, world!");
          }
      }
    learner_created: false
- name: test/Tests.java
  visible: false
  text: |-
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.stage.StageTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.TestedProgram;

    public class Tests extends StageTest<String> {
        // multiple line output
        @DynamicTest(order = 1)
        CheckResult multipleLineOutputTest() {

            TestedProgram main = new TestedProgram();
            main.start("./test/lausanne.json");
            String output = main.execute("/output \"m1\"").trim();

            String[] stations = new String[]{"Renes—Gare", "Epenex", "Crochy", "Cerisaie",
                "Bassenges", "EPFL", "UNL—Sorge", "Mouline", "UNL—Chemberonne", "Bourdonnette", "Melley",
                "Provence", "Montelly", "Vigie", "Lausanne—Flon"};

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertStations(output, stations);

            stations = new String[]{"Croisettes", "Vennes", "Fourmi", "Sallaz", "CHUV", "Ours",
                "Riponne M.Bejart", "Bessieres", "Lausanne—Flon", "Lausanne Gare CFF", "Grancy", "Delices", "Jourdils",
                "Ouchy—Olympique"};

            output = main.execute("/output \"m2\"");
            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertStations(output, stations);

            return CheckResult.correct();
        }

        // addition test
        @DynamicTest(order = 2)
        CheckResult additionTest() {

            TestedProgram main = new TestedProgram();
            main.start("./test/lausanne.json");

            // added a station to the end of the line
            main.execute("/append \"m1\" \"Test station 1\"");
            String output = main.execute("/output \"m1\"");

            String[] stations = new String[]{"Renes—Gare", "Epenex", "Crochy", "Cerisaie",
                "Bassenges", "EPFL", "UNL—Sorge", "Mouline", "UNL—Chemberonne", "Bourdonnette", "Melley",
                "Provence", "Montelly", "Vigie", "Lausanne—Flon", "Test station 1"};

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertStations(output, stations);

            // added another one
            main.execute("/append \"m1\" \"Test station 2\"");
            output = main.execute("/output \"m1\"");

            stations = new String[]{"Renes—Gare", "Epenex", "Crochy", "Cerisaie",
                "Bassenges", "EPFL", "UNL—Sorge", "Mouline", "UNL—Chemberonne", "Bourdonnette", "Melley",
                "Provence", "Montelly", "Vigie", "Lausanne—Flon", "Test station 1", "Test station 2"};

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertStations(output, stations);

            // added one station to the beginning of the line
            main.execute("/add-head \"m1\" \"Head\"");
            output = main.execute("/output \"m1\"");

            stations = new String[]{"Head", "Renes—Gare", "Epenex", "Crochy", "Cerisaie",
                "Bassenges", "EPFL", "UNL—Sorge", "Mouline", "UNL—Chemberonne", "Bourdonnette", "Melley",
                "Provence", "Montelly", "Vigie", "Lausanne—Flon", "Test station 1", "Test station 2"};

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertStations(output, stations
            );

            return CheckResult.correct();
        }

        // not existing file check
        @DynamicTest(order = 3)
        CheckResult nonexistingFileTest() {
            TestedProgram main = new TestedProgram();
            String output = main.start("tHiS_fIlE_DoEs_nOt_ExIsT.txt");
            if (output.trim().length() == 0) {
                return CheckResult.wrong("The program did not print anything when the file was not exist. ");
            }
            if (output.toLowerCase().startsWith("depot") || output.toLowerCase().endsWith("depot")) {
                return CheckResult.wrong("It looks like the program did not print an error message when the file was not exist.");
            }
            return CheckResult.correct();
        }

        // output with transfers
        @DynamicTest(order = 4)
        CheckResult outputLineWithTransfer() {
            TestedProgram main = new TestedProgram();
            main.start("./test/prague.json");

            String[][] stations = new String[][]{
                {"Nemocnice Motol", null},
                {"Petriny", null},
                {"Nadrazi Veleslavin", null},
                {"Borislavka", null},
                {"Dejvicka", null},
                {"Hradcanska", null},
                {"Malostranska", null},
                {"Staromestska", null},
                {"Mustek", "Linka B"},
                {"Muzeum", "Linka C"},
                {"Namesti Miru", null},
                {"Jiriho z Podebrad", null},
                {"Flora", null},
                {"Zelivskeho", null},
                {"Strasnicka", null},
                {"Skalka", null},
                {"Depo Hostivar", null}
            };

            String output = main.execute("/output \"Linka A\"");
            checkDepots(output);

            checkOutputLength(output, stations.length + 2);
            assertWithTransfer(output, stations);

            return CheckResult.correct();
        }

        // connections test
        @DynamicTest(order = 5)
        CheckResult connectLinesTest() {

            TestedProgram main = new TestedProgram();
            main.start("./test/prague.json");

            String[][] stations = new String[][]{{"Nemocnice Motol", null}, {"Petriny", "Linka C"},
                {"Nadrazi Veleslavin", null}, {"Borislavka", null}, {"Dejvicka", null}, {"Hradcanska", null},
                {"Malostranska", null}, {"Staromestska", null}, {"Mustek", "Linka B"}, {"Muzeum", "Linka C"},
                {"Namesti Miru", null}, {"Jiriho z Podebrad", null}, {"Flora", null}, {"Zelivskeho", null},
                {"Strasnicka", null}, {"Skalka", null}, {"Depo Hostivar", null}
            };
            main.execute("/connect \"Linka C\" \"I.P.Pavlova\" \"Linka A\" \"Petriny\"");

            String output = main.execute("/output \"Linka A\"");

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertWithTransfer(output, stations);

            return CheckResult.correct();
        }

        @DynamicTest(order = 6)
        CheckResult simpleRouteTest() {
            TestedProgram main = new TestedProgram();
            main.start("./test/prague.json");

            String[] correctRoute = {"Petriny", "Nadrazi Veleslavin", "Borislavka", "Dejvicka", "Hradcanska", "Malostranska",
                "Staromestska", "Mustek", "Muzeum", "Namesti Miru", "Jiriho z Podebrad", "Flora"};

            String[] sOutput = main.execute("/route \"Linka A\" \"Petriny\" \"Linka A\" \"Flora\"").toLowerCase().split("\n");

            if (sOutput.length != correctRoute.length) {
                return CheckResult.wrong("Your program printed an incorrect number of stations in the route.\n" +
                    "Expected: " + correctRoute.length + " stations." +
                    "\nYour output: " + sOutput.length + " stations.");
            }

            for (int i = 0; i < correctRoute.length; i++) {
                if (i == 0 && !correctRoute[i].equalsIgnoreCase(sOutput[i])) {
                    return CheckResult.wrong("The first station in the output should be '" + correctRoute[i] + "'.");
                } else if (i != 0) {
                    if (!correctRoute[i].equalsIgnoreCase(sOutput[i])) {
                        return CheckResult.wrong("After '" + correctRoute[i - 1] + "' should be '" + correctRoute[i] + "'.");
                    }
                }
            }

            return CheckResult.correct();
        }

        // advanced route test
        @DynamicTest(order = 7)
        CheckResult advancedRouteTest() {
            TestedProgram main = new TestedProgram();
            main.start("./test/prague.json");

            String[] route = {"Vysehrad", "I.P.Pavlova", "Muzeum",
                "Linka A", "Muzeum", "Mustek",
                "Linka B", "Mustek", "Namesti Republiky"};
            String[] sOutput = main.execute("/route \"Linka C\" \"Vysehrad\" \"Linka B\" \"Namesti Republiky\"").split("\n");

            if (sOutput.length != 9) {
                return CheckResult.wrong("Your program printed an incorrect number of stations in the route.");
            }

            int index = 0;
            for (String station : sOutput) {
                if (!station.toLowerCase().trim().contains(route[index].toLowerCase())) {
                    return CheckResult.wrong("The route is incorrect. Wrong stations were displayed");
                }
                index++;
            }

            return CheckResult.correct();
        }

        // simple test with time
        @DynamicTest(order = 8)
        CheckResult simpleTime() {
            TestedProgram main = new TestedProgram();
            main.start("./test/prague_w_time.json");

            String[] route = {"Borislavka", "Dejvicka", "Hradcanska", "Malostranska", "Staromestska", "Mustek", "Muzeum",
                "Namesti Miru", "Jiriho z Podebrad", "Flora", "44"};
            String[] sOutput = main.execute("/fastest-route \"Linka A\" \"Borislavka\" \"Linka A\" \"Flora\"").split("\n");

            if (sOutput.length != route.length) {
                return CheckResult.wrong("Your program printed an incorrect number of stations in the route. Expected 10 stations and the total time!");
            }

            int index = 0;
            for (String station : sOutput) {
                if (!station.toLowerCase().trim().contains(route[index].toLowerCase())) {
                    return CheckResult.wrong("The route is incorrect. Wrong stations were displayed");
                }
                index++;
            }

            return CheckResult.correct();
        }

        // advanced test with time
        @DynamicTest(order = 9)
        CheckResult advancedTime() {
            TestedProgram main = new TestedProgram();
            main.start("./test/prague_w_time.json");

            String[] route = {"Vysehrad", "I.P.Pavlova", "Muzeum", "Hlavni nadrazi", "Florenc",
                "Linka B", "Florenc", "Namesti Republiky", "29"
            };

            String[] sOutput = main.execute("/fastest-route \"Linka C\" \"Vysehrad\" \"Linka B\" \"Namesti Republiky\"")
                .split("\n");

            if (sOutput.length != 9) {
                return CheckResult.wrong("Your program printed an incorrect number of stations in the route. Expected 8 stations and the total time!");
            }

            int index = 0;
            for (String station : sOutput) {
                if (!station.toLowerCase().trim().contains(route[index].toLowerCase())) {
                    return CheckResult.wrong("The route is incorrect. Wrong stations were displayed");
                }
                index++;
            }

            return CheckResult.correct();
        }

        // checks for "depot" at the start and at the end
        void checkDepots(String output) {
            output = output.trim().toLowerCase();
            if (!output.startsWith("depot")) {
                throw new WrongAnswer("Your output should start with 'depot'.");
            } else if (!output.endsWith("depot")) {
                throw new WrongAnswer("Your output should end with 'depot'.");
            }
        }

        // checks number of stations in output
        void checkOutputLength(String output, int correctLength) {
            int length = output.trim().split("\n").length;
            if (length != correctLength) {
                throw new WrongAnswer("You output contains wrong number of lines.\n" +
                    "Expected: " + correctLength + " lines\n" +
                    "Your output: " + length + " lines");
            }
        }

        // checks stations
        void assertStations(String output, String[] stations) {

            String[] sOutput = output.trim().split("\n");

            for (int i = 0; i < stations.length; i++) {
                if (!sOutput[i + 1].equals(stations[i])) {
                    throw new WrongAnswer("Can't find station '" + stations[i] + "' in the line number " + (i + 2));
                }
            }
        }

        void assertWithTransfer(String output, String[][] stations) {

            String[] sOutput = output.split("\n");

            for (int i = 0; i < stations.length; i++) {
                String currentLine = sOutput[i + 1].toLowerCase().trim();
                String currentStation = stations[i][0];
                String currentTransfer = stations[i][1];
                if (currentTransfer == null) {
                    if (!currentLine.equals(currentStation.toLowerCase())) {
                        throw new WrongAnswer("There is an error in your program's reply. Some stations were not found.");
                    }
                } else if (!currentLine.contains(currentStation.toLowerCase()) ||
                    !currentLine.contains(currentTransfer.toLowerCase())) {
                    throw new WrongAnswer("Expected transfer to '" + currentTransfer + "' from '" + currentStation + "' station.");
                }
            }
        }
    }
  learner_created: false
- name: test/lausanne.json
  visible: false
  text: |-
    {
      "m1": {
        "1": {
          "name": "Renes—Gare",
          "transfer": [],
          "time": 3
        },
        "2": {
          "name": "Epenex",
          "transfer": [],
          "time": 2
        },
        "3": {
          "name": "Crochy",
          "transfer": [],
          "time": 6
        },
        "4": {
          "name": "Cerisaie",
          "transfer": [],
          "time": 5
        },
        "5": {
          "name": "Bassenges",
          "transfer": [],
          "time": 4
        },
        "6": {
          "name": "EPFL",
          "transfer": [],
          "time": 6
        },
        "7": {
          "name": "UNL—Sorge",
          "transfer": [],
          "time": 8
        },
        "8": {
          "name": "Mouline",
          "transfer": [],
          "time": 5
        },
        "9": {
          "name": "UNL—Chemberonne",
          "transfer": [],
          "time": 4
        },
        "10": {
          "name": "Bourdonnette",
          "transfer": [],
          "time": 5
        },
        "11": {
          "name": "Melley",
          "transfer": [],
          "time": 7
        },
        "12": {
          "name": "Provence",
          "transfer": [],
          "time": 6
        },
        "13": {
          "name": "Montelly",
          "transfer": [],
          "time": 5
        },
        "14": {
          "name": "Vigie",
          "transfer": [],
          "time": 4
        },
        "15": {
          "name": "Lausanne—Flon",
          "transfer": [],
          "time": null
        }
      },
      "m2": {
        "1": {
          "name": "Croisettes",
          "transfer": [],
          "time": 6
        },
        "2": {
          "name": "Vennes",
          "transfer": [],
          "time": 5
        },
        "3": {
          "name": "Fourmi",
          "transfer": [],
          "time": 4
        },
        "4": {
          "name": "Sallaz",
          "transfer": [],
          "time": 6
        },
        "5": {
          "name": "CHUV",
          "transfer": [],
          "time": 5
        },
        "6": {
          "name": "Ours",
          "transfer": [],
          "time": 3
        },
        "7": {
          "name": "Riponne M.Bejart",
          "transfer": [],
          "time": 4
        },
        "8": {
          "name": "Bessieres",
          "transfer": [],
          "time": 6
        },
        "9": {
          "name": "Lausanne—Flon",
          "transfer": [],
          "time": 5
        },
        "10": {
          "name": "Lausanne Gare CFF",
          "transfer": [],
          "time": 3
        },
        "11": {
          "name": "Grancy",
          "transfer": [],
          "time": 4
        },
        "12": {
          "name": "Delices",
          "transfer": [],
          "time": 6
        },
        "13": {
          "name": "Jourdils",
          "transfer": [],
          "time": 3
        },
        "14": {
          "name": "Ouchy—Olympique",
          "transfer": [],
          "time": null
        }
      }
    }
  learner_created: false
  - name: test/prague.json
    visible: false
    text: |-
      {
        "Linka A": {
          "1": {
            "name": "Nemocnice Motol" ,
            "transfer": []
          } ,
          "2": {
            "name": "Petriny" ,
            "transfer": []
          } ,
          "3": {
            "name": "Nadrazi Veleslavin" ,
            "transfer": []
          } ,
          "4": {
            "name": "Borislavka" ,
            "transfer": []
          } ,
          "5": {
            "name": "Dejvicka" ,
            "transfer": []
          } ,
          "6": {
            "name": "Hradcanska" ,
            "transfer": []
          } ,
          "7": {
            "name": "Malostranska" ,
            "transfer": []
          } ,
          "8": {
            "name": "Staromestska" ,
            "transfer": []
          } ,
          "9": {
            "name": "Mustek" ,
            "transfer": [
              {
                "line": "Linka B" ,
                "station": "Mustek"
              }
            ]
          } ,
          "10": {
            "name": "Muzeum" ,
            "transfer": [
              {
                "line": "Linka C" ,
                "station": "Muzeum"
              }
            ]
          } ,
          "11": {
            "name": "Namesti Miru" ,
            "transfer": []
          } ,
          "12": {
            "name": "Jiriho z Podebrad" ,
            "transfer": []
          } ,
          "13": {
            "name": "Flora" ,
            "transfer": []
          } ,
          "14": {
            "name": "Zelivskeho" ,
            "transfer": []
          } ,
          "15": {
            "name": "Strasnicka" ,
            "transfer": []
          } ,
          "16": {
            "name": "Skalka" ,
            "transfer": []
          } ,
          "17": {
            "name": "Depo Hostivar" ,
            "transfer": []
          }
        } ,
        "Linka B": {
          "1": {
            "name": "Cerny Most" ,
            "transfer": []
          } ,
          "2": {
            "name": "Rajska zahrada" ,
            "transfer": []
          } ,
          "3": {
            "name": "Hloubetin" ,
            "transfer": []
          } ,
          "4": {
            "name": "Kolbenova" ,
            "transfer": []
          } ,
          "5": {
            "name": "Vysocanska" ,
            "transfer": []
          } ,
          "6": {
            "name": "Ceskomoravska" ,
            "transfer": []
          } ,
          "7": {
            "name": "Palmovka" ,
            "transfer": []
          } ,
          "8": {
            "name": "Invalidovna" ,
            "transfer": []
          } ,
          "9": {
            "name": "Krizikova" ,
            "transfer": []
          } ,
          "10": {
            "name": "Florenc" ,
            "transfer": [
              {
                "line": "Linka C" ,
                "station": "Florenc"
              }
            ]
          } ,
          "11": {
            "name": "Namesti Republiky" ,
            "transfer": []
          } ,
          "12": {
            "name": "Mustek" ,
            "transfer": [
              {
                "line": "Linka B" ,
                "station": "Mustek"
              }
            ]
          } ,
          "13": {
            "name": "Narodni trida" ,
            "transfer": []
          } ,
          "14": {
            "name": "Karlovo namesti" ,
            "transfer": []
          } ,
          "15": {
            "name": "Andel" ,
            "transfer": []
          } ,
          "16": {
            "name": "Smichovske nadrazi" ,
            "transfer": []
          } ,
          "17": {
            "name": "Radlicka" ,
            "transfer": []
          } ,
          "18": {
            "name": "Jinonice" ,
            "transfer": []
          } ,
          "19": {
            "name": "Nove Butovice" ,
            "transfer": []
          } ,
          "20": {
            "name": "Hurka" ,
            "transfer": []
          } ,
          "21": {
            "name": "Luziny" ,
            "transfer": []
          } ,
          "22": {
            "name": "Luka" ,
            "transfer": []
          } ,
          "23": {
            "name": "Stodulky" ,
            "transfer": []
          } ,
          "24": {
            "name": "Zlicin" ,
            "transfer": []
          }
        } ,
        "Linka C": {
          "1": {
            "name": "Letnany" ,
            "transfer": []
          } ,
          "2": {
            "name": "Prosek" ,
            "transfer": []
          } ,
          "3": {
            "name": "Strizkov" ,
            "transfer": []
          } ,
          "4": {
            "name": "Ladvi" ,
            "transfer": []
          } ,
          "5": {
            "name": "Kobylisy" ,
            "transfer": []
          } ,
          "6": {
            "name": "Nadrazi Holesovice" ,
            "transfer": []
          } ,
          "7": {
            "name": "Vltavska" ,
            "transfer": []
          } ,
          "8": {
            "name": "Florenc" ,
            "transfer": [
              {
                "line": "Linka B" ,
                "station": "Florenc"
              }
            ]
          } ,
          "9": {
            "name": "Hlavni nadrazi" ,
            "transfer": []
          } ,
          "10": {
            "name": "Muzeum" ,
            "transfer": [
              {
                "line": "Linka A" ,
                "station": "Muzeum"
              }
            ]
          } ,
          "11": {
            "name": "I.P.Pavlova" ,
            "transfer": []
          } ,
          "12": {
            "name": "Vysehrad" ,
            "transfer": []
          } ,
          "13": {
            "name": "Prazskeho povstani" ,
            "transfer": []
          } ,
          "14": {
            "name": "Pankrac" ,
            "transfer": []
          } ,
          "15": {
            "name": "Budejovicka" ,
            "transfer": []
          } ,
          "16": {
            "name": "Kacerov" ,
            "transfer": []
          } ,
          "17": {
            "name": "Roztyly" ,
            "transfer": []
          } ,
          "18": {
            "name": "Chodov" ,
            "transfer": []
          } ,
          "19": {
            "name": "Opatov" ,
            "transfer": []
          } ,
          "20": {
            "name": "Haje" ,
            "transfer": []
          }
        }
      }
    learner_created: false
  - name: src/metro/route/ShortestRouteFinder.java
    visible: true
    text: |
      package metro.route;
      
      import metro.ds.GraphUtils;
      import metro.model.Station;
      import metro.model.StationVertex;
      import metro.model.Transfer;
      import metro.storage.SubwayStorage;
      
      import java.util.Iterator;
      import java.util.List;
      import java.util.Objects;
      
      class ShortestRouteFinder extends SubwayRouteFinder {
          ShortestRouteFinder(SubwayStorage storage) {
              super(storage);
          }
      
          private StationVertex stationFromTransfer(final Transfer t) {
              Station station = getStorage()
                      .findStation(t.getLine(), t.getStation());
              return StationVertex.fromStation(t.getLine(), station);
          }
      
          @Override
          public Route find(final Transfer start, Transfer end) {
              final StationVertex startV = stationFromTransfer(start);
              final StationVertex endV = stationFromTransfer(end);
              List<StationVertex> path = GraphUtils.shortestPath(getStorage().asGraph(), startV, endV);
              RouteBuilder rb = new RouteBuilder(start);
              Iterator<StationVertex> iterator = path.iterator();
              Transfer pTransfer = start;
              StationVertex p = iterator.next();
              while (iterator.hasNext()) {
                  StationVertex cur = iterator.next();
                  Transfer byPrevLine = byLine(pTransfer.getLine(), cur);
                  if (byPrevLine != null) {
                      rb.point(byPrevLine);
                      pTransfer = byPrevLine;
                  } else {
                      addTransition(rb, p, cur);
                      pTransfer = rb.last();
                  }
                  p = cur;
              }
              return rb.build();
          }
      
          private void addTransition(RouteBuilder rb, final StationVertex cur, StationVertex next) {
              boolean found = false;
              for (Transfer transfer : cur.getTransfers()) {
                  for (Transfer nextTransfer : next.getTransfers()) {
                      final boolean sameLine = Objects.equals(transfer.getLine(), nextTransfer.getLine());
                      if (sameLine) {
                          if (found) {
                              throw new IllegalStateException("Multiple Transitions");
                          }
                          rb.transition(transfer);
                          rb.point(nextTransfer);
                          found = true;
                      }
                  }
              }
              if (!found) {
                  throw new IllegalStateException("Should contains one transition");
              }
          }
      
          private Transfer byLine(final String line, StationVertex vertex) {
              return vertex.getTransfers().stream()
                      .filter(t -> Objects.equals(t.getLine(), line))
                      .findAny().orElse(null);
          }
      }
    learner_created: true
  - name: src/metro/model/Station.java
    visible: true
    text: |
      package metro.model;
      
      import java.util.ArrayList;
      import java.util.List;
      import java.util.Objects;
      
      public class Station {
          private String name;
      
          public Station(String name) {
              this.name = name;
              this.transfer = new ArrayList<>();
          }
      
          public String getName() {
              return name;
          }
      
          public void setName(String name) {
              this.name = name;
          }
      
      
          public void addTransfer(final String lineName, String station) {
              addTransfer(new Transfer(lineName, station));
          }
      
      
          public List<Transfer> getTransfer() {
              return transfer;
          }
      
          public void setTransfer(List<Transfer> transfer) {
              this.transfer = transfer;
          }
      
          private List<Transfer> transfer;
      
          public void addTransfer(Transfer station2) {
              transfer.add(station2);
          }
      
          public boolean hasTransfer() {
              return transfer != null && !transfer.isEmpty();
          }
      
          @Override
          public boolean equals(Object o) {
              if (this == o) {
                  return true;
              }
              if (o == null || getClass() != o.getClass()) {
                  return false;
              }
              Station station = (Station) o;
              return Objects.equals(name, station.name);
          }
      
          @Override
          public int hashCode() {
              return Objects.hash(name);
          }
      }
    learner_created: true
  - name: src/metro/storage/InMemorySubwayStorage.java
    visible: true
    text: |
      package metro.storage;
      
      import metro.ds.Graph;
      import metro.model.Station;
      import metro.model.StationVertex;
      import metro.model.Transfer;
      import metro.route.Route;
      import metro.route.RouteFinder;
      
      import java.util.ArrayList;
      import java.util.Deque;
      import java.util.HashMap;
      import java.util.LinkedList;
      import java.util.List;
      import java.util.Map;
      import java.util.Objects;
      import java.util.concurrent.ConcurrentLinkedDeque;
      
      public class InMemorySubwayStorage implements SubwayStorage {
          private final Map<String, Deque<Station>> storage;
      
          public InMemorySubwayStorage(Map<String, Deque<Station>> storage) {
              this.storage = storage;
          }
      
          @Override
          public List<Station> stationsByLine(String lineName) {
              return new ArrayList<>(storage.get(lineName));
          }
      
          @Override
          public void append(String lineName, String stationName) {
              storage.computeIfAbsent(lineName, n -> new ConcurrentLinkedDeque<>())
                      .add(new Station(stationName));
          }
      
          @Override
          public void addHead(String lineName, String stationName) {
              storage.computeIfAbsent(lineName, n -> new LinkedList<>())
                      .addFirst(new Station(stationName));
          }
      
          @Override
          public void remove(String lineName, String stationName) {
              Deque<Station> stations = storage.get(lineName);
              if (stations != null) {
                  stations.remove(findByName(stations, stationName));
              }
          }
      
          @Override
          public void connect(Transfer station1, Transfer station2) {
              findStation(station1.getLine(), station1.getStation())
                      .addTransfer(station2);
              findStation(station2.getLine(), station2.getStation())
                      .addTransfer(station1);
          }
      
          private StationVertex vertexFromTransfer(Transfer transfer) {
              Station station = findStation(transfer.getLine(), transfer.getStation());
              return StationVertex.fromStation(transfer.getLine(), station);
          }
      
          @Override
          public Route route(Transfer transfer1, Transfer transfer2) {
              final RouteFinder finder = RouteFinder.shortest(this);
              return finder.find(transfer1, transfer2);
          }
      
          @Override
          public Graph<StationVertex> asGraph() {
              final Graph<StationVertex> g = Graph.directed();
              Map<Transfer, StationVertex> stationVertexDict = new HashMap<>();
              for (Map.Entry<String, Deque<Station>> e : storage.entrySet()) {
                  final String line = e.getKey();
                  Deque<Station> lineStations = e.getValue();
                  StationVertex prev = null;
                  for (Station station : lineStations) {
                      StationVertex u = stationVertexDict.computeIfAbsent(new Transfer(line, station.getName()), this::computeStationVertex);
                      if (prev != null) {
                          g.addEdge(prev, u);
                          g.addEdge(u, prev);
                      }
                      prev = u;
                      g.addNode(u);
                      List<Transfer> transfer = station.getTransfer();
                      if (transfer != null) {
                          transfer.forEach(t -> {
                              StationVertex v = stationVertexDict.computeIfAbsent(t, this::computeStationVertex);
                              g.addEdge(u, v);
                              g.addEdge(v, u);
                          });
                      }
                  }
              }
              return g;
          }
      
          @Override
          public Station findStation(final String lineName, final String stationName) {
              Deque<Station> stations = storage.get(lineName);
              return findByName(stations, stationName);
          }
      
          private Station findByName(Deque<Station> stations, String stationName) {
              return stations.stream()
                      .filter(st -> Objects.equals(st.getName(), stationName))
                      .findFirst()
                      .orElse(null);
          }
      
          private StationVertex computeStationVertex(Transfer tr) {
              return StationVertex.fromStation(tr.getLine(), findStation(tr.getLine(), tr.getStation()));
          }
      }
    learner_created: true
  - name: src/metro/ds/AdjacencyListsGraph.java
    visible: true
    text: |
      package metro.ds;
      
      import java.util.Collection;
      import java.util.Collections;
      import java.util.HashMap;
      import java.util.LinkedHashSet;
      import java.util.Map;
      import java.util.Set;
      
      class AdjacencyListsGraph<U> implements Graph<U> {
          private final Map<U, Set<U>> adjacencyList = new HashMap<>();
      
          @Override
          public boolean isAdjacent(U u, U v) {
              return adjacencyList.containsKey(u) && adjacencyList.get(u)
                      .contains(v);
          }
      
          @Override
          public Collection<U> neighbors(U u) {
              return Collections.unmodifiableSet(
                      adjacencyList.getOrDefault(u, Collections.emptySet()));
          }
      
          @Override
          public void addNode(U u) {
              adjacencyList.putIfAbsent(u, new LinkedHashSet<>());
          }
      
          @Override
          public void removeNode(U u) {
              adjacencyList.remove(u);
          }
      
          @Override
          public void addEdge(U u, U v) {
              addNode(u);
              addNode(v);
              adjacencyList.computeIfPresent(u, (u1, us) -> {
                  us.add(v);
                  return us;
              });
          }
      
          @Override
          public void removeEdge(U u, U v) {
              adjacencyList.computeIfPresent(u, (u1, us) -> {
                  us.remove(v);
                  return us;
              });
          }
      }
    learner_created: true
  - name: src/metro/storage/SubwayStorage.java
    visible: true
    text: "package metro.storage;\n\nimport com.google.gson.Gson;\nimport com.google.gson.reflect.TypeToken;\n\
    import metro.ds.Graph;\nimport metro.model.Station;\nimport metro.model.StationVertex;\n\
    import metro.model.Transfer;\nimport metro.route.Route;\n\nimport java.io.IOException;\n\
    import java.io.Reader;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\
    import java.util.ArrayDeque;\nimport java.util.Comparator;\nimport java.util.Deque;\n\
    import java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\
    \npublic interface SubwayStorage {\n    List<Station> stationsByLine(final String\
    \ lineName);\n\n    void append(String lineName, String stationName);\n\n    void\
    \ addHead(String lineName, String stationName);\n\n    void remove(String lineName,\
    \ String stationName);\n    \n    static SubwayStorage fromJsonFile(Path pathToFile)\
    \ throws IOException {\n        Gson gson = new Gson();\n        TypeToken<Map<String,\
    \ Map<String, Station>>> mapTypeToken = new TypeToken<Map<String, Map<String,\
    \ Station>>>() {\n        };\n        try (final Reader reader = Files.newBufferedReader(pathToFile))\
    \ {\n            Map<String, Map<String, Station>> storage = gson.fromJson(reader,\
    \ mapTypeToken.getType());\n            return new InMemorySubwayStorage(storage.entrySet().stream()\n\
    \                    .collect(Collectors.toMap(Map.Entry::getKey, e -> mapToDeque(e.getValue()))));\n\
    \        }\n    }\n\n    static Deque<Station> mapToDeque(final Map<String, Station>\
    \ map) {\n        return map.entrySet()\n                .stream()\n         \
    \       .sorted(Comparator.comparingInt(e -> Integer.parseInt(e.getKey())))\n\
    \                .map(Map.Entry::getValue)\n                .collect(Collectors.toCollection(ArrayDeque::new));\n\
    \    }\n\n    void connect(Transfer station1, Transfer station2);\n\n    Route\
    \ route(Transfer transfer1, Transfer transfer2);\n\n    Graph<StationVertex> asGraph();\n\
    \n    Station findStation(String lineName, String stationName);\n}\n"
    learner_created: true
  - name: src/metro/model/Transfer.java
    visible: true
    text: |
      package metro.model;
      
      import java.util.Objects;
      
      public class Transfer {
          private String line;
      
          @Override
          public boolean equals(Object o) {
              if (this == o) {
                  return true;
              }
              if (o == null || getClass() != o.getClass()) {
                  return false;
              }
              Transfer transfer = (Transfer) o;
              return Objects.equals(line, transfer.line) && Objects.equals(station, transfer.station);
          }
      
          @Override
          public int hashCode() {
              return Objects.hash(line, station);
          }
      
          public Transfer(String line, String station) {
              this.line = line;
              this.station = station;
          }
      
          private String station;
      
          public String getLine() {
              return line;
          }
      
          public void setLine(String line) {
              this.line = line;
          }
      
          public String getStation() {
              return station;
          }
      
          public void setStation(String station) {
              this.station = station;
          }
      }
    learner_created: true
  - name: src/metro/ds/GraphUtils.java
    visible: true
    text: |
      package metro.ds;
      
      
      import java.util.ArrayDeque;
      import java.util.ArrayList;
      import java.util.Collection;
      import java.util.Collections;
      import java.util.HashMap;
      import java.util.List;
      import java.util.Map;
      import java.util.Queue;
      
      public class GraphUtils {
          private GraphUtils() {
      
          }
      
          public static <T> List<T> shortestPath(Graph<T> graph, T u, T v) {
              Queue<T> queue = new ArrayDeque<>();
              Map<T, List<T>> paths = new HashMap<>();
              queue.add(u);
              paths.put(u, Collections.singletonList(u));
              while (!queue.isEmpty() && !paths.containsKey(v)) {
                  T el = queue.remove();
                  Collection<T> neighbors = graph.neighbors(el);
                  List<T> pathToNode = paths.get(el);
                  for (T neighbor : neighbors) {
                      if (!paths.containsKey(neighbor)) {
                          queue.add(neighbor);
                          List<T> pathToNeighbor = new ArrayList<>(pathToNode);
                          pathToNeighbor.add(neighbor);
                          paths.put(neighbor, Collections.unmodifiableList(pathToNeighbor));
                      }
                  }
              }
              return paths.get(v);
          }
      }
    learner_created: true
  - name: src/metro/route/RouteBuilder.java
    visible: true
    text: |
      package metro.route;
      
      import metro.model.Transfer;
      
      import java.util.ArrayDeque;
      import java.util.ArrayList;
      import java.util.Deque;
      
      public class RouteBuilder {
          private final Deque<RoutePoint> transfers;
      
          public RouteBuilder(Transfer start) {
              this.transfers = new ArrayDeque<>();
              transfers.add(RoutePoint.point(start));
          }
      
          public RouteBuilder(RouteBuilder routeBuilder) {
              this.transfers = new ArrayDeque<>(routeBuilder.transfers);
          }
      
          public RouteBuilder point(Transfer transfer) {
              transfers.add(RoutePoint.point(transfer));
              return this;
          }
      
          public RouteBuilder transition(Transfer transitionStation) {
              RoutePoint last = transfers.pollLast();
              if (last == null || last.hasTransition()) {
                  throw new IllegalStateException();
              }
              transfers.add(RoutePoint.transition(last.getStation(), transitionStation));
              return this;
          }
      
          public Route build() {
              return new SimpleRoute(new ArrayList<>(transfers));
          }
      
          public Transfer last() {
              RoutePoint lastRoutePoint = this.transfers.peek();
              if (lastRoutePoint == null) {
                  throw new IllegalStateException("Empty route");
              }
              return lastRoutePoint.hasTransition() ? lastRoutePoint.getTransition() : lastRoutePoint.getStation();
          }
      }
    learner_created: true
  - name: src/metro/route/RouteFinder.java
    visible: true
    text: |
      package metro.route;
      
      import metro.model.Transfer;
      import metro.storage.SubwayStorage;
      
      @FunctionalInterface
      public interface RouteFinder {
          static RouteFinder shortest(SubwayStorage inMemorySubwayStorage) {
              return new ShortestRouteFinder(inMemorySubwayStorage);
          }
      
          Route find(Transfer start, Transfer end);
      
      }
    learner_created: true
  - name: src/metro/commands/ConsoleCommand.java
    visible: true
    text: |
      package metro.commands;
      
      
      import java.util.ArrayList;
      import java.util.Collections;
      import java.util.List;
      import java.util.regex.Matcher;
      import java.util.regex.Pattern;
      
      public class ConsoleCommand {
          private static final Pattern NAME_PATTERN = Pattern.compile("/(\\S+)");
          private static final Pattern ARG_PATTERN = Pattern.compile("\\s*(\"([^\"]+)\"|(\\S+))\\s*");
      
          public List<String> getArgs() {
              return args;
          }
      
          private final String type;
          private final List<String> args;
      
          private ConsoleCommand(String type, List<String> args) {
              this.type = type;
              this.args = args;
          }
      
          public static ConsoleCommand parse(String cmd) {
              final Matcher nameMatcher = NAME_PATTERN.matcher(cmd);
              final String cmdName;
              final String argsPart;
              if (nameMatcher.find() && nameMatcher.start() == 0) {
                  cmdName = nameMatcher.group(1);
                  argsPart = cmd.substring(nameMatcher.end());
              } else {
                  throw new IllegalStateException("Incorrect format of command. Command: " + cmd);
              }
              Matcher argMatcher = ARG_PATTERN.matcher(argsPart);
              List<String> args = new ArrayList<>();
              while (argMatcher.find()) {
                  String group = argMatcher.group(2);
                  final String value = group == null? argMatcher.group(3) : group;
                  args.add(value);
              }
              return new ConsoleCommand(cmdName, Collections.unmodifiableList(args));
          }
      
          public String getType() {
              return type;
          }
      }
    learner_created: true
  - name: src/metro/commands/ConnectCommand.java
    visible: true
    text: |
      package metro.commands;
      
      import metro.model.Transfer;
      import metro.storage.SubwayStorage;
      
      public class ConnectCommand implements StorageCommand {
          private final Transfer transfer1;
          private final Transfer transfer2;
      
          public ConnectCommand(Transfer transfer1, Transfer transfer2) {
              this.transfer1 = transfer1;
              this.transfer2 = transfer2;
          }
      
          @Override
          public void run(SubwayStorage storage) {
              storage.connect(transfer1, transfer2);
          }
      }
    learner_created: true
  - name: src/metro/commands/StorageCommands.java
    visible: true
    text: |
      package metro.commands;
      
      import metro.printer.Printer;
      
      public class StorageCommands {
      
          private StorageCommands() {
          }
      
          static StorageCommand append(final String lineName, final String stationName) {
              return new AppendCommand(lineName, stationName);
          }
      
          static StorageCommand addHead(final String lineName, final String stationName) {
              return storage -> storage.addHead(lineName, stationName);
          }
          public static StorageCommand remove(final String lineName, final String stationName) {
              return storage -> storage.remove(lineName, stationName);
          }
      
          public static StorageCommand output(final String lineName) {
              return storage -> Printer.stations(storage.stationsByLine(lineName)).print();
          }
      
          public static StorageCommand exit() {
              return storage -> System.exit(0);
          }
      }
    learner_created: true
  - name: src/metro/printer/Printer.java
    visible: true
    text: |
      package metro.printer;
      
      import metro.model.Station;
      import metro.route.Route;
      
      import java.util.List;
      
      public interface Printer {
          static Printer route(Route route) {
              return new RouterPrinter(route);
          }
      
          void print();
      
          static Printer stations(final List<Station> stations) {
              return new StationsPrinter(stations);
          }
      }
    learner_created: true
  - name: src/metro/route/Route.java
    visible: true
    text: |
      package metro.route;
      
      import java.util.List;
      
      public interface Route {
          List<RoutePoint> points();
      
          RoutePoint last();
      }
    learner_created: true
  - name: src/metro/ds/Graph.java
    visible: true
    text: |
      package metro.ds;
      
      import java.util.Collection;
      
      public interface Graph<U> {
          boolean isAdjacent(U u, U v);
      
          Collection<U> neighbors(U u);
      
          void addNode(U u);
      
          void removeNode(U u);
      
          void addEdge(U u, U v);
      
          void removeEdge(U u, U v);
      
          static <T> Graph<T> directed() {
              return new AdjacencyListsGraph<>();
          }
      }
    learner_created: true
  - name: src/metro/commands/RouteCommand.java
    visible: true
    text: |
      package metro.commands;
      
      import metro.model.Transfer;
      import metro.printer.Printer;
      import metro.route.Route;
      import metro.storage.SubwayStorage;
      
      public class RouteCommand implements StorageCommand {
          private final Transfer t1;
          private final Transfer t2;
      
          public RouteCommand(Transfer t1, Transfer t2) {
              this.t1 = t1;
              this.t2 = t2;
          }
      
          @Override
          public void run(SubwayStorage storage) {
              final Route route = storage.route(t1, t2);
              Printer.route(route).print();
          }
      }
    learner_created: true
  - name: src/metro/printer/RouterPrinter.java
    visible: true
    text: |
      package metro.printer;
      
      import metro.model.Transfer;
      import metro.route.Route;
      import metro.route.RoutePoint;
      
      class RouterPrinter implements Printer {
          private final Route route;
      
          RouterPrinter(Route route) {
              this.route = route;
          }
      
          @Override
          public void print() {
              for (RoutePoint point : route.points()) {
                  System.out.println(point.getStation().getStation());
                  if (point.hasTransition()) {
                      Transfer transition = point.getTransition();
                      System.out.println("Transition to line " + transition.getLine());
                      System.out.println(transition.getStation());
                  }
              }
          }
      }
    learner_created: true
  - name: src/metro/commands/AppendCommand.java
    visible: true
    text: |
      package metro.commands;
      
      import metro.storage.SubwayStorage;
      
      public class AppendCommand implements StorageCommand {
          private final String lineName;
          private final String stationName;
      
          public AppendCommand(String lineName, String stationName) {
              this.lineName = lineName;
              this.stationName = stationName;
          }
      
          @Override
          public void run(SubwayStorage storage) {
              storage.append(lineName, stationName);
          }
      }
    learner_created: true
  - name: src/metro/model/StationVertex.java
    visible: true
    text: |
      package metro.model;
      
      import java.util.Collections;
      import java.util.LinkedHashSet;
      import java.util.Objects;
      import java.util.Set;
      
      public class StationVertex {
          private final Set<Transfer> transfers;
      
          private StationVertex(Set<Transfer> transfers) {
              this.transfers = transfers;
          }
      
          public static StationVertex fromStation(String line, Station station) {
              Set<Transfer> transfers = new LinkedHashSet<>(station.getTransfer());
              transfers.add(new Transfer(line, station.getName()));
              return new StationVertex(Collections.unmodifiableSet(transfers));
          }
      
          @Override
          public boolean equals(Object o) {
              if (this == o) {
                  return true;
              }
              if (o == null || getClass() != o.getClass()) {
                  return false;
              }
              StationVertex that = (StationVertex) o;
              return Objects.equals(transfers, that.transfers);
          }
      
          @Override
          public int hashCode() {
              return Objects.hash(transfers);
          }
      
          public Set<Transfer> getTransfers() {
              return transfers;
          }
      }
    learner_created: true
  - name: src/metro/route/SimpleRoute.java
    visible: true
    text: |
      package metro.route;
      
      import java.util.ArrayDeque;
      import java.util.ArrayList;
      import java.util.Deque;
      import java.util.List;
      
      class SimpleRoute implements Route {
          private final Deque<RoutePoint> routePoints;
      
          SimpleRoute(List<RoutePoint> routePoints) {
              this.routePoints = new ArrayDeque<>(routePoints);
          }
      
          @Override
          public List<RoutePoint> points() {
              return new ArrayList<>(routePoints);
          }
      
          @Override
          public RoutePoint last() {
              return routePoints.poll();
          }
      }
    learner_created: true
  - name: src/metro/route/SubwayRouteFinder.java
    visible: true
    text: |
      package metro.route;
      
      import metro.storage.SubwayStorage;
      
      abstract class SubwayRouteFinder implements RouteFinder {
          public SubwayStorage getStorage() {
              return storage;
          }
      
          private final SubwayStorage storage;
      
          SubwayRouteFinder(SubwayStorage storage) {
              this.storage = storage;
          }
      
      }
    learner_created: true
  - name: src/metro/commands/StorageCommandFactory.java
    visible: true
    text: |
      package metro.commands;
      
      public interface StorageCommandFactory {
          StorageCommand get();
      
          static StorageCommand fromCommand(final String cmd) {
              return new StorageCommandFactoryImpl(ConsoleCommand.parse(cmd))
                      .get();
          }
      }
    learner_created: true
  - name: src/metro/route/RoutePoint.java
    visible: true
    text: |
      package metro.route;
      
      import metro.model.Transfer;
      
      public class RoutePoint {
          private final Transfer station;
          private final Transfer transition;
      
          public Transfer getTransition() {
              return transition;
          }
      
          private RoutePoint(Transfer stations, Transfer transition) {
              this.station = stations;
              this.transition = transition;
          }
      
          private RoutePoint(Transfer transfer) {
              this(transfer, null);
          }
      
          static RoutePoint transition(Transfer stations, Transfer transition) {
              return new RoutePoint(stations, transition);
          }
      
          static RoutePoint point(Transfer transfer) {
              return new RoutePoint(transfer);
          }
      
          public boolean hasTransition() {
              return transition != null;
          }
      
          public Transfer getStation() {
              return station;
          }
      }
    learner_created: true
  - name: src/metro/commands/StorageCommandFactoryImpl.java
    visible: true
    text: |
      package metro.commands;
      
      import metro.model.Transfer;
      
      import java.util.List;
      
      public class StorageCommandFactoryImpl implements StorageCommandFactory {
          private final ConsoleCommand command;
      
          public StorageCommandFactoryImpl(ConsoleCommand command) {
              this.command = command;
          }
      
          @Override
          public StorageCommand get() {
              final String type = command.getType();
              final List<String> args = command.getArgs();
              switch (type) {
                  case "append":
                      return StorageCommands.append(args.get(0), args.get(1));
                  case "add-head":
                      return StorageCommands.addHead(args.get(0), args.get(1));
                  case "output":
                      return StorageCommands.output(args.get(0));
                  case "remove":
                      return StorageCommands.remove(args.get(0), args.get(1));
                  case "connect":
                      final Transfer st1 = new Transfer(args.get(0), args.get(1));
                      final Transfer st2 = new Transfer(args.get(2), args.get(3));
                      return new ConnectCommand(st1, st2);
                  case "route":
                      final Transfer t1 = new Transfer(args.get(0), args.get(1));
                      final Transfer t2 = new Transfer(args.get(2), args.get(3));
                      return new RouteCommand(t1, t2);
                  case "exit":
                      return StorageCommands.exit();
                  default:
                      throw new IllegalStateException("Unsupported command : " + type);
              }
          }
      }
    learner_created: true
  - name: src/metro/commands/StorageCommand.java
    visible: true
    text: |
      package metro.commands;
      
      import metro.storage.SubwayStorage;
      
      @FunctionalInterface
      public interface StorageCommand {
      
          void run(SubwayStorage storage);
      }
    learner_created: true
  - name: src/metro/printer/StationsPrinter.java
    visible: true
    text: |
      package metro.printer;
      
      import metro.model.Station;
      import metro.model.Transfer;
      
      import java.util.ArrayDeque;
      import java.util.ArrayList;
      import java.util.Collections;
      import java.util.Deque;
      import java.util.List;
      
      class StationsPrinter implements Printer {
          public static final Station DEPOT = new Station("depot");
          private final List<Station> stations;
      
          public StationsPrinter(List<Station> stations) {
              final Deque<Station> deque = new ArrayDeque<>(stations);
              deque.addFirst(DEPOT);
              this.stations = Collections.unmodifiableList(new ArrayList<>(deque));
          }
      
          @Override
          public void print() {
              for (Station station : stations) {
                  System.out.println(printStation(station));
              }
              System.out.println(printStation(DEPOT));
          }
      
      
          private String printStation(Station station) {
              if (station == null) {
                  return null;
              }
              final StringBuilder sb = new StringBuilder(station.getName());
              final List<Transfer> transfer = station.getTransfer();
              if (transfer != null && !transfer.isEmpty()) {
                  for (Transfer t : transfer) {
      
                      sb.append(" - ")
                              .append(t.getStation())
                              .append(" (")
                              .append(t.getLine())
                              .append(")");
                  }
              }
              return sb.toString();
          }
      
      }
    learner_created: true
  - name: test/prague_w_time.json
    visible: false
    text: |-
      {
        "Linka A": {
          "0": {
            "name": "Nemocnice Motol",
            "transfer": [],
            "time": 5
          },
          "1": {
            "name": "Petriny",
            "transfer": [],
            "time": 5
          },
          "2": {
            "name": "Nadrazi Veleslavin",
            "transfer": [],
            "time": 3
          },
        "3": {
          "name": "Borislavka",
          "transfer": [],
          "time": 3
        },
        "4": {
          "name": "Dejvicka",
          "transfer": [],
          "time": 4
        },
        "5": {
          "name": "Hradcanska",
          "transfer": [],
          "time": 4
        },
        "6": {
          "name": "Malostranska",
          "transfer": [],
          "time": 1
        },
        "7": {
          "name": "Staromestska",
          "transfer": [],
          "time": 7
        },
        "8": {
          "name": "Mustek",
          "transfer": [
            {
              "line": "Linka B",
              "station": "Mustek"
            }
          ],
          "time": 8
        },
        "9": {
          "name": "Muzeum",
          "transfer": [
            {
              "line": "Linka C",
              "station": "Muzeum"
            }
          ],
          "time": 5
        },
        "10": {
          "name": "Namesti Miru",
          "transfer": [],
          "time": 7
        },
        "11": {
          "name": "Jiriho z Podebrad",
          "transfer": [],
          "time": 5
        },
        "12": {
          "name": "Flora",
          "transfer": [],
          "time": 7
        },
        "13": {
          "name": "Zelivskeho",
          "transfer": [],
          "time": 1
        },
        "14": {
          "name": "Strasnicka",
          "transfer": [],
          "time": 7
        },
        "15": {
          "name": "Skalka",
          "transfer": [],
          "time": 2
        },
        "16": {
          "name": "Depo Hostivar",
          "transfer": [],
          "time": null
        }
      },
      "Linka B": {
        "0": {
          "name": "Cerny Most",
          "transfer": [],
          "time": 3
        },
        "1": {
          "name": "Rajska zahrada",
          "transfer": [],
          "time": 5
        },
        "2": {
          "name": "Hloubetin",
          "transfer": [],
          "time": 4
        },
        "3": {
          "name": "Kolbenova",
          "transfer": [],
          "time": 1
        },
        "4": {
          "name": "Vysocanska",
          "transfer": [],
          "time": 6
        },
        "5": {
          "name": "Ceskomoravska",
          "transfer": [],
          "time": 5
        },
        "6": {
          "name": "Palmovka",
          "transfer": [],
          "time": 7
        },
        "7": {
          "name": "Invalidovna",
          "transfer": [],
          "time": 5
        },
        "8": {
          "name": "Krizikova",
          "transfer": [],
          "time": 1
        },
        "9": {
          "name": "Florenc",
          "transfer": [
            {
              "line": "Linka C",
              "station": "Florenc"
            }
          ],
          "time": 5
        },
        "10": {
          "name": "Namesti Republiky",
          "transfer": [],
          "time": 3
        },
        "11": {
          "name": "Mustek",
          "transfer": [
            {
              "line": "Linka A",
              "station": "Mustek"
            }
          ],
          "time": 7
        },
        "12": {
          "name": "Narodni trida",
          "transfer": [],
          "time": 3
        },
        "13": {
          "name": "Karlovo namesti",
          "transfer": [],
          "time": 4
        },
        "14": {
          "name": "Andel",
          "transfer": [],
          "time": 3
        },
        "15": {
          "name": "Smichovske nadrazi",
          "transfer": [],
          "time": 3
        },
        "16": {
          "name": "Radlicka",
          "transfer": [],
          "time": 4
        },
        "17": {
          "name": "Jinonice",
          "transfer": [],
          "time": 7
        },
        "18": {
          "name": "Nove Butovice",
          "transfer": [],
          "time": 2
        },
        "19": {
          "name": "Hurka",
          "transfer": [],
          "time": 7
        },
        "20": {
          "name": "Luziny",
          "transfer": [],
          "time": 5
        },
        "21": {
          "name": "Luka",
          "transfer": [],
          "time": 6
        },
        "22": {
          "name": "Stodulky",
          "transfer": [],
          "time": 7
        },
        "23": {
          "name": "Zlicin",
          "transfer": [],
          "time": null
        }
      },
      "Linka C": {
        "0": {
          "name": "Letnany",
          "transfer": [],
          "time": 3
        },
        "1": {
          "name": "Prosek",
          "transfer": [],
          "time": 7
        },
        "2": {
          "name": "Strizkov",
          "transfer": [],
          "time": 5
        },
        "3": {
          "name": "Ladvi",
          "transfer": [],
          "time": 4
        },
        "4": {
          "name": "Kobylisy",
          "transfer": [],
          "time": 5
        },
        "5": {
          "name": "Nadrazi Holesovice",
          "transfer": [],
          "time": 7
        },
        "6": {
          "name": "Vltavska",
          "transfer": [],
          "time": 2
        },
        "7": {
          "name": "Florenc",
          "transfer": [
            {
              "line": "Linka B",
              "station": "Florenc"
            }
          ],
          "time": 7
        },
        "8": {
          "name": "Hlavni nadrazi",
          "transfer": [],
          "time": 2
        },
        "9": {
          "name": "Muzeum",
          "transfer": [
            {
              "line": "Linka A",
              "station": "Muzeum"
            }
          ],
          "time": 5
        },
        "10": {
          "name": "I.P.Pavlova",
          "transfer": [],
          "time": 5
        },
        "11": {
          "name": "Vysehrad",
          "transfer": [],
          "time": 4
        },
        "12": {
          "name": "Prazskeho povstani",
          "transfer": [],
          "time": 7
        },
        "13": {
          "name": "Pankrac",
          "transfer": [],
          "time": 5
        },
        "14": {
          "name": "Budejovicka",
          "transfer": [],
          "time": 5
        },
        "15": {
          "name": "Kacerov",
          "transfer": [],
          "time": 4
        },
        "16": {
          "name": "Roztyly",
          "transfer": [],
            "time": 7
          },
          "17": {
            "name": "Chodov",
            "transfer": [],
            "time": 6
          },
          "18": {
            "name": "Opatov",
            "transfer": [],
            "time": 5
          },
          "19": {
            "name": "Haje",
            "transfer": [],
            "time": null
          }
        }
      }
    learner_created: false
  - name: src/metro/ds/WeightedGraph.java
    visible: true
    learner_created: true
  - name: src/metro/route/FastestSubwayRouteFinder.java
    visible: true
    learner_created: true
  - name: src/metro/ds/WeightedPath.java
    visible: true
    learner_created: true
  - name: src/metro/commands/FastestRouteCommand.java
    visible: true
    learner_created: true
  - name: test/prague_c.json
    visible: true
    learner_created: true
feedback_link: https://hyperskill.org/learn/step/10345#comment
status: Solved
feedback:
  message: Congratulations!
  time: Sat, 09 Apr 2022 22:01:15 UTC
record: 4
