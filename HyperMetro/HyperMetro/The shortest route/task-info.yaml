type: edu
files:
  - name: src/metro/Main.java
  visible: true
  text: |
    package metro;

    public class Main {
        public static void main(String[] args) {
            System.out.println("Hello, world!");
        }
    }
  learner_created: false
- name: test/Tests.java
  visible: false
  text: |-
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.stage.StageTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.TestedProgram;

    import java.util.Arrays;

    public class Tests extends StageTest<String> {
        // test from the previous stage with one line
        @DynamicTest(order = 1)
        CheckResult oneLineTest() {

            TestedProgram main = new TestedProgram();
            main.start("./test/baltimore.json");
            String output = main.execute("/output \"SubwayLink\"").trim();

            String[] stations = new String[]{"Owings Mills", "Old Court", "Milford Mill", "Reiserstown Plaza",
                "Rogers Avenue", "West Cold Spring", "Mondawmin", "Penn North", "Uptown", "State Center",
                "Lexington Market", "Charles Center", "Shot Tower/Market Place", "Johns Hopkins Hospital"};

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertStations(output, stations);

            return CheckResult.correct();
        }

        // test of example
        @DynamicTest(order = 2)
        CheckResult multipleLineOutputTest() {

            TestedProgram main = new TestedProgram();
            main.start("./test/lausanne.json");
            String output = main.execute("/output \"m1\"").trim();

            String[] stations = new String[]{"Renes—Gare", "Epenex", "Crochy", "Cerisaie",
                "Bassenges", "EPFL", "UNL—Sorge", "Mouline", "UNL—Chemberonne", "Bourdonnette", "Melley",
                "Provence", "Montelly", "Vigie", "Lausanne—Flon"};

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertStations(output, stations);

            output = main.execute("/output \"m2\"");

            stations = new String[]{"Croisettes", "Vennes", "Fourmi", "Sallaz", "CHUV", "Ours",
                "Riponne M.Bejart", "Bessieres", "Lausanne—Flon", "Lausanne Gare CFF", "Grancy", "Delices", "Jourdils",
                "Ouchy—Olympique"};

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertStations(output, stations);

            return CheckResult.correct();
        }

        // example test pt.2 (with addition)
        @DynamicTest(order = 3)
        CheckResult additionTest() {

            TestedProgram main = new TestedProgram();
            main.start("./test/lausanne.json");

            // added a station to the end of the line
            main.execute("/append \"m1\" \"Test station 1\"");
            String output = main.execute("/output \"m1\"");

            String[] stations = new String[]{"Renes—Gare", "Epenex", "Crochy", "Cerisaie",
                "Bassenges", "EPFL", "UNL—Sorge", "Mouline", "UNL—Chemberonne", "Bourdonnette", "Melley",
                "Provence", "Montelly", "Vigie", "Lausanne—Flon", "Test station 1"};

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertStations(output, stations);

            // added another one
            main.execute("/append \"m1\" \"Test station 2\"");
            output = main.execute("/output \"m1\"");

            stations = new String[]{"Renes—Gare", "Epenex", "Crochy", "Cerisaie",
                "Bassenges", "EPFL", "UNL—Sorge", "Mouline", "UNL—Chemberonne", "Bourdonnette", "Melley",
                "Provence", "Montelly", "Vigie", "Lausanne—Flon", "Test station 1", "Test station 2"};

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertStations(output, stations);

            // added one station to the beginning of the line
            main.execute("/add-head \"m1\" \"Head\"");
            output = main.execute("/output \"m1\"");

            stations = new String[]{"Head", "Renes—Gare", "Epenex", "Crochy", "Cerisaie",
                "Bassenges", "EPFL", "UNL—Sorge", "Mouline", "UNL—Chemberonne", "Bourdonnette", "Melley",
                "Provence", "Montelly", "Vigie", "Lausanne—Flon", "Test station 1", "Test station 2"};

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertStations(output, stations);

            return CheckResult.correct();
        }

        // not existing file check
        @DynamicTest(order = 4)
        CheckResult nonexistingFileTest() {
            TestedProgram main = new TestedProgram();
            String output = main.start("tHiS_fIlE_DoEs_nOt_ExIsT.txt");
            if (output.trim().length() == 0) {
                return CheckResult.wrong("The program did not print anything when the file was not exist. ");
            }
            if (output.toLowerCase().startsWith("depot") || output.toLowerCase().endsWith("depot")) {
                return CheckResult.wrong("It looks like the program did not print an error message when the file was not exist.");
            }
            return CheckResult.correct();
        }

        // test of a case from the example
        @DynamicTest(order = 5)
        CheckResult outputLineWithTransfer() {
            TestedProgram main = new TestedProgram();
            main.start("./test/prague.json");

            String[][] stations = new String[][]{
                {"Nemocnice Motol", null},
                {"Petriny", null},
                {"Nadrazi Veleslavin", null},
                {"Borislavka", null},
                {"Dejvicka", null},
                {"Hradcanska", null},
                {"Malostranska", null},
                {"Staromestska", null},
                {"Mustek", "Linka B"},
                {"Muzeum", "Linka C"},
                {"Namesti Miru", null},
                {"Jiriho z Podebrad", null},
                {"Flora", null},
                {"Zelivskeho", null},
                {"Strasnicka", null},
                {"Skalka", null},
                {"Depo Hostivar", null}
            };

            String output = main.execute("/output \"Linka A\"");
            checkDepots(output);

            checkOutputLength(output, stations.length + 2);
            assertWithTransfer(output, stations);

            return CheckResult.correct();
        }

        @DynamicTest(order = 6)
        CheckResult connectLinesTest() {
            TestedProgram main = new TestedProgram();
            main.start("./test/prague.json");

            String[][] stations = new String[][]{
                {"Nemocnice Motol", null},
                {"Petriny", "Linka C"},
                {"Nadrazi Veleslavin", null},
                {"Borislavka", null},
                {"Dejvicka", null},
                {"Hradcanska", null},
                {"Malostranska", null},
                {"Staromestska", null},
                {"Mustek", "Linka B"},
                {"Muzeum", "Linka C"},
                {"Namesti Miru", null},
                {"Jiriho z Podebrad", null},
                {"Flora", null},
                {"Zelivskeho", null},
                {"Strasnicka", null},
                {"Skalka", null},
                {"Depo Hostivar", null}
            };

            main.execute("/connect \"Linka C\" \"I.P.Pavlova\" \"Linka A\" \"Petriny\"");
            String output = main.execute("/output \"Linka A\"");

            checkDepots(output);
            checkOutputLength(output, stations.length + 2);
            assertWithTransfer(output, stations);

            return CheckResult.correct();
        }

        @DynamicTest(order = 7)
        CheckResult simpleRouteTest() {
            TestedProgram main = new TestedProgram();
            main.start("./test/prague.json");

            String[] correctRoute = {"Petriny", "Nadrazi Veleslavin", "Borislavka", "Dejvicka", "Hradcanska", "Malostranska",
                "Staromestska", "Mustek", "Muzeum", "Namesti Miru", "Jiriho z Podebrad", "Flora"};

            String[] sOutput = main.execute("/route \"Linka A\" \"Petriny\" \"Linka A\" \"Flora\"").toLowerCase().split("\n");

            if (sOutput.length != correctRoute.length) {
                return CheckResult.wrong("Your program printed an incorrect number of stations in the route.\n" +
                    "Expected: " + correctRoute.length + " stations." +
                    "\nYour output: " + sOutput.length + " stations.");
            }

            for (int i = 0; i < correctRoute.length; i++) {
                if (i == 0 && !correctRoute[i].toLowerCase().equals(sOutput[i].toLowerCase())) {
                    return CheckResult.wrong("The first station in the output should be '" + correctRoute[i] + "'.");
                } else if (i != 0) {
                    if (!correctRoute[i].toLowerCase().equals(sOutput[i].toLowerCase())) {
                        return CheckResult.wrong("After '" + correctRoute[i - 1] + "' should be '" + correctRoute[i] + "'.");
                    }
                }
            }

            return CheckResult.correct();
        }

        @DynamicTest(order = 8)
        CheckResult advancedRouteTest() {

            TestedProgram main = new TestedProgram();
            main.start("./test/prague.json");

            String[] stations = {"Vysehrad", "I.P.Pavlova", "Muzeum",
                "Transition to line Linka A", "Muzeum", "Mustek",
                "Transition to line Linka B", "Mustek", "Namesti Republiky"};
            String[] sOutput = main.execute("/route \"Linka C\" \"Vysehrad\" \"Linka B\" \"Namesti Republiky\"").split("\n");

            if (sOutput.length != stations.length) {
                return CheckResult.wrong("Your program printed an incorrect number of stations in the route.\n" +
                    "Expected: " + (stations.length - 4) + " stations and 2 transitions. Output should be " + stations.length + " lines." +
                    "\nYour output: " + sOutput.length + " lines");
            }

            for (int i = 0; i < stations.length; i++) {
                if (i == 0 && !stations[i].toLowerCase().equals(sOutput[i].toLowerCase())) {
                    return CheckResult.wrong("The first station in the output should be " + stations[i]);
                } else if (i != 0) {
                    if (!stations[i].toLowerCase().equals(sOutput[i].toLowerCase())) {
                        return CheckResult.wrong("After '" + stations[i - 1] + "' should be '" + stations[i] + "'.");
                    }
                }
            }
            return CheckResult.correct();
        }

        // checks for "depot" at the start and at the end
        void checkDepots(String output) {
            output = output.trim().toLowerCase();
            if (!output.startsWith("depot")) {
                throw new WrongAnswer("Your output should start with 'depot'.");
            } else if (!output.endsWith("depot")) {
                throw new WrongAnswer("Your output should end with 'depot'.");
            }
        }

        // checks number of stations in output
        void checkOutputLength(String output, int correctLength) {
            int length = output.trim().split("\n").length;
            if (length != correctLength) {
                throw new WrongAnswer("You output contains wrong number of lines.\n" +
                    "Expected: " + correctLength + " lines\n" +
                    "Your output: " + length + " lines");
            }
        }

        // checks stations
        void assertStations(String output, String[] stations) {

            String[] sOutput = output.trim().split("\n");

            for (int i = 0; i < stations.length; i++) {
                if (!sOutput[i + 1].equals(stations[i])) {
                    throw new WrongAnswer("Can't find station '" + stations[i] + "' in the line number " + (i + 2));
                }
            }
        }

        void assertWithTransfer(String output, String[][] stations) {

            String[] sOutput = output.split("\n");

            for (int i = 0; i < stations.length; i++) {
                String currentLine = sOutput[i + 1].toLowerCase().trim();
                String currentStation = stations[i][0];
                String currentTransfer = stations[i][1];
                if (currentTransfer == null) {
                    if (!currentLine.equals(currentStation.toLowerCase())) {
                        throw new WrongAnswer("There is an error in your program's reply. Some stations were not found.");
                    }
                } else if (!currentLine.contains(currentStation.toLowerCase()) ||
                    !currentLine.contains(currentTransfer.toLowerCase())) {
                    throw new WrongAnswer("Expected transfer to '" + currentTransfer + "' from '" + currentStation + "' station.");
                }
            }
        }
    }
  learner_created: false
- name: test/prague.json
  visible: false
  text: |-
    {
      "Linka A": {
        "1": {
          "name": "Nemocnice Motol" ,
          "transfer": []
        } ,
        "2": {
          "name": "Petriny" ,
          "transfer": []
        } ,
        "3": {
          "name": "Nadrazi Veleslavin" ,
          "transfer": []
        } ,
        "4": {
          "name": "Borislavka" ,
          "transfer": []
        } ,
        "5": {
          "name": "Dejvicka" ,
          "transfer": []
        } ,
        "6": {
          "name": "Hradcanska" ,
          "transfer": []
        } ,
        "7": {
          "name": "Malostranska" ,
          "transfer": []
        } ,
        "8": {
          "name": "Staromestska" ,
          "transfer": []
        } ,
        "9": {
          "name": "Mustek" ,
          "transfer": [
            {
              "line": "Linka B" ,
              "station": "Mustek"
            }
          ]
        } ,
        "10": {
          "name": "Muzeum" ,
          "transfer": [
            {
              "line": "Linka C" ,
              "station": "Muzeum"
            }
          ]
        } ,
        "11": {
          "name": "Namesti Miru" ,
          "transfer": []
        } ,
        "12": {
          "name": "Jiriho z Podebrad" ,
          "transfer": []
        } ,
        "13": {
          "name": "Flora" ,
          "transfer": []
        } ,
        "14": {
          "name": "Zelivskeho" ,
          "transfer": []
        } ,
        "15": {
          "name": "Strasnicka" ,
          "transfer": []
        } ,
        "16": {
          "name": "Skalka" ,
          "transfer": []
        } ,
        "17": {
          "name": "Depo Hostivar" ,
          "transfer": []
        }
      } ,
      "Linka B": {
        "1": {
          "name": "Cerny Most" ,
          "transfer": []
        } ,
        "2": {
          "name": "Rajska zahrada" ,
          "transfer": []
        } ,
        "3": {
          "name": "Hloubetin" ,
          "transfer": []
        } ,
        "4": {
          "name": "Kolbenova" ,
          "transfer": []
        } ,
        "5": {
          "name": "Vysocanska" ,
          "transfer": []
        } ,
        "6": {
          "name": "Ceskomoravska" ,
          "transfer": []
        } ,
        "7": {
          "name": "Palmovka" ,
          "transfer": []
        } ,
        "8": {
          "name": "Invalidovna" ,
          "transfer": []
        } ,
        "9": {
          "name": "Krizikova" ,
          "transfer": []
        } ,
        "10": {
          "name": "Florenc" ,
          "transfer": [
            {
              "line": "Linka C" ,
              "station": "Florenc"
            }
          ]
        } ,
        "11": {
          "name": "Namesti Republiky" ,
          "transfer": []
        } ,
        "12": {
          "name": "Mustek" ,
          "transfer": [
            {
              "line": "Linka A" ,
              "station": "Mustek"
            }
          ]
        } ,
        "13": {
          "name": "Narodni trida" ,
          "transfer": []
        } ,
        "14": {
          "name": "Karlovo namesti" ,
          "transfer": []
        } ,
        "15": {
          "name": "Andel" ,
          "transfer": []
        } ,
        "16": {
          "name": "Smichovske nadrazi" ,
          "transfer": []
        } ,
        "17": {
          "name": "Radlicka" ,
          "transfer": []
        } ,
        "18": {
          "name": "Jinonice" ,
          "transfer": []
        } ,
        "19": {
          "name": "Nove Butovice" ,
          "transfer": []
        } ,
        "20": {
          "name": "Hurka" ,
          "transfer": []
        } ,
        "21": {
          "name": "Luziny" ,
          "transfer": []
        } ,
        "22": {
          "name": "Luka" ,
          "transfer": []
        } ,
        "23": {
          "name": "Stodulky" ,
          "transfer": []
        } ,
        "24": {
          "name": "Zlicin" ,
          "transfer": []
        }
      } ,
      "Linka C": {
        "1": {
          "name": "Letnany" ,
          "transfer": []
        } ,
        "2": {
          "name": "Prosek" ,
          "transfer": []
        } ,
        "3": {
          "name": "Strizkov" ,
          "transfer": []
        } ,
        "4": {
          "name": "Ladvi" ,
          "transfer": []
        } ,
        "5": {
          "name": "Kobylisy" ,
          "transfer": []
        } ,
        "6": {
          "name": "Nadrazi Holesovice" ,
          "transfer": []
        } ,
        "7": {
          "name": "Vltavska" ,
          "transfer": []
        } ,
        "8": {
          "name": "Florenc" ,
          "transfer": [
            {
              "line": "Linka B" ,
              "station": "Florenc"
            }
          ]
        } ,
        "9": {
          "name": "Hlavni nadrazi" ,
          "transfer": []
        } ,
        "10": {
          "name": "Muzeum" ,
          "transfer": [
            {
              "line": "Linka A" ,
              "station": "Muzeum"
            }
          ]
        } ,
        "11": {
          "name": "I.P.Pavlova" ,
          "transfer": []
        } ,
        "12": {
          "name": "Vysehrad" ,
          "transfer": []
        } ,
        "13": {
          "name": "Prazskeho povstani" ,
          "transfer": []
        } ,
        "14": {
          "name": "Pankrac" ,
          "transfer": []
        } ,
        "15": {
          "name": "Budejovicka" ,
          "transfer": []
        } ,
        "16": {
          "name": "Kacerov" ,
          "transfer": []
        } ,
        "17": {
          "name": "Roztyly" ,
          "transfer": []
        } ,
        "18": {
          "name": "Chodov" ,
          "transfer": []
        } ,
        "19": {
          "name": "Opatov" ,
          "transfer": []
        } ,
        "20": {
          "name": "Haje" ,
          "transfer": []
        }
      }
    }
  learner_created: false
- name: test/lausanne.json
  visible: false
  text: |-
    {
      "m1": {
        "1": {
          "name": "Renes—Gare",
          "transfer": []
        },
        "2": {
          "name": "Epenex",
          "transfer": []
        },
        "3": {
          "name": "Crochy",
          "transfer": []
        },
        "4": {
          "name": "Cerisaie",
          "transfer": []
        },
        "5": {
          "name": "Bassenges",
          "transfer": []
        },
        "6": {
          "name": "EPFL",
          "transfer": []
        },
        "7": {
          "name": "UNL—Sorge",
          "transfer": []
        },
        "8": {
          "name": "Mouline",
          "transfer": []
        },
        "9": {
          "name": "UNL—Chemberonne",
          "transfer": []
        },
        "10": {
          "name": "Bourdonnette",
          "transfer": []
        },
        "11": {
          "name": "Melley",
          "transfer": []
        },
        "12": {
          "name": "Provence",
          "transfer": []
        },
        "13": {
          "name": "Montelly",
          "transfer": []
        },
        "14": {
          "name": "Vigie",
          "transfer": []
        },
        "15": {
          "name": "Lausanne—Flon",
          "transfer": []
        }
      },
      "m2": {
        "1": {
          "name": "Croisettes",
          "transfer": []
        },
        "2": {
          "name": "Vennes",
          "transfer": []
        },
        "3": {
          "name": "Fourmi",
          "transfer": []
        },
        "4": {
          "name": "Sallaz",
          "transfer": []
        },
        "5": {
          "name": "CHUV",
          "transfer": []
        },
        "6": {
          "name": "Ours",
          "transfer": []
        },
        "7": {
          "name": "Riponne M.Bejart",
          "transfer": []
        },
        "8": {
          "name": "Bessieres",
          "transfer": []
        },
        "9": {
          "name": "Lausanne—Flon",
          "transfer": []
        },
        "10": {
          "name": "Lausanne Gare CFF",
          "transfer": []
        },
        "11": {
          "name": "Grancy",
          "transfer": []
        },
        "12": {
          "name": "Delices",
          "transfer": []
        },
        "13": {
          "name": "Jourdils",
          "transfer": []
        },
        "14": {
          "name": "Ouchy—Olympique",
          "transfer": []
        }
      }
    }
  learner_created: false
- name: test/baltimore.json
  visible: false
  text: |-
    {
      "SubwayLink": {
        "1": {
          "name": "Owings Mills",
          "transfer": [],
          "time": 2
        },
        "2": {
          "name": "Old Court",
          "transfer": [],
          "time": 4
        },
        "3": {
          "name": "Milford Mill",
          "transfer": [],
          "time": 6
        },
        "4": {
          "name": "Reiserstown Plaza",
          "transfer": [],
          "time": 3
        },
        "5": {
          "name": "Rogers Avenue",
          "transfer": [],
          "time": 2
        },
        "6": {
          "name": "West Cold Spring",
          "transfer": [],
          "time": 6
        },
        "7": {
          "name": "Mondawmin",
          "transfer": [],
          "time": 4
        },
        "8": {
          "name": "Penn North",
          "transfer": [],
          "time": 5
        },
        "9": {
          "name": "Uptown",
          "transfer": [],
          "time": 7
        },
        "10": {
          "name": "State Center",
          "transfer": [],
          "time": 3
        },
        "11": {
          "name": "Lexington Market",
          "transfer": [],
          "time": 5
        },
        "12": {
          "name": "Charles Center",
          "transfer": [],
          "time": 6
        },
        "13": {
          "name": "Shot Tower/Market Place",
          "transfer": [],
          "time": 4
        },
        "14": {
          "name": "Johns Hopkins Hospital",
          "transfer": [], "time": null
        }
      }
    }
  learner_created: false
- name: src/metro/printer/Printer.java
  visible: true
  text: |
    package metro.printer;

    import metro.model.Station;

    import java.util.List;

    public interface Printer {
        void print();

         static Printer stations(final List<Station> stations) {
            return new StationsPrinter(stations);
        }
    }
  learner_created: true
- name: src/metro/model/Station.java
  visible: true
  text: |
    package metro.model;

    import java.util.ArrayList;
    import java.util.List;

    public class Station {
        private String name;

        public Station(String name) {
            this.name = name;
            this.transfer = new ArrayList<>();
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }


        public void addTransfer(final String lineName, String station) {
            addTransfer(new Transfer(lineName, station));
        }


        public List<Transfer> getTransfer() {
            return transfer;
        }

        public void setTransfer(List<Transfer> transfer) {
            this.transfer = transfer;
        }

        private List<Transfer> transfer;

        public void addTransfer(Transfer station2) {
            transfer.add(station2);
        }
    }
  learner_created: true
- name: src/metro/storage/InMemorySubwayStorage.java
  visible: true
  text: "package metro.storage;\n\nimport metro.model.Station;\nimport metro.model.Transfer;\n\
    \nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.LinkedList;\n\
    import java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport\
    \ java.util.concurrent.ConcurrentLinkedDeque;\n\npublic class InMemorySubwayStorage\
    \ implements SubwayStorage {\n    private final Map<String, Deque<Station>> storage;\n\
    \n    public InMemorySubwayStorage(Map<String, Deque<Station>> storage) {\n  \
    \      this.storage = storage;\n    }\n\n    @Override\n    public List<Station>\
    \ stationsByLine(String lineName) {\n        return new ArrayList<>(storage.get(lineName));\n\
    \    }\n\n    @Override\n    public void append(String lineName, String stationName)\
    \ {\n        storage.computeIfAbsent(lineName, n -> new ConcurrentLinkedDeque<>())\n\
    \                .add(new Station(stationName));\n    }\n\n    @Override\n   \
    \ public void addHead(String lineName, String stationName) {\n        storage.computeIfAbsent(lineName,\
    \ n -> new LinkedList<>())\n                .addFirst(new Station(stationName));\n\
    \    }\n\n    @Override\n    public void remove(String lineName, String stationName)\
    \ {\n        Deque<Station> stations = storage.get(lineName);\n        if (stations\
    \ != null) {\n            stations.remove(findByName(stations, stationName));\n\
    \        }\n    }   \n\n    @Override\n    public void connect(Transfer station1,\
    \ Transfer station2) {\n        findStation(station1.getLine(), station1.getStation())\n\
    \                .addTransfer(station2);\n        findStation(station2.getLine(),\
    \ station2.getStation())\n                .addTransfer(station1);\n    }\n\n \
    \   private Station findStation(final String lineName, final String stationName)\
    \ {\n        Deque<Station> stations = storage.get(lineName);\n        return\
    \ findByName(stations, stationName);\n    }\n\n    private Station findByName(Deque<Station>\
    \ stations, String stationName) {\n        return stations.stream()\n        \
    \        .filter(st -> Objects.equals(st.getName(), stationName))\n          \
    \      .findFirst()\n                .orElse(null);\n    }\n}\n"
  learner_created: true
- name: src/metro/commands/AppendCommand.java
  visible: true
  text: |
    package metro.commands;

    import metro.storage.SubwayStorage;

    public class AppendCommand implements StorageCommand {
        private final String lineName;
        private final String stationName;

        public AppendCommand(String lineName, String stationName) {
            this.lineName = lineName;
            this.stationName = stationName;
        }

        @Override
        public void run(SubwayStorage storage) {
            storage.append(lineName, stationName);
        }
    }
  learner_created: true
- name: src/metro/storage/SubwayStorage.java
  visible: true
  text: "package metro.storage;\n\nimport com.google.gson.Gson;\nimport com.google.gson.reflect.TypeToken;\n\
    import metro.model.Station;\nimport metro.model.Transfer;\n\nimport java.io.IOException;\n\
    import java.io.Reader;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\n\
    import java.util.ArrayDeque;\nimport java.util.Comparator;\nimport java.util.Deque;\n\
    import java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\
    \npublic interface SubwayStorage {\n    List<Station> stationsByLine(final String\
    \ lineName);\n\n    void append(String lineName, String stationName);\n\n    void\
    \ addHead(String lineName, String stationName);\n\n    void remove(String lineName,\
    \ String stationName);\n    \n    static SubwayStorage fromJsonFile(Path pathToFile)\
    \ throws IOException {\n        Gson gson = new Gson();\n        TypeToken<Map<String,\
    \ Map<String, Station>>> mapTypeToken = new TypeToken<Map<String, Map<String,\
    \ Station>>>() {\n        };\n        try (final Reader reader = Files.newBufferedReader(pathToFile))\
    \ {\n            Map<String, Map<String, Station>> storage = gson.fromJson(reader,\
    \ mapTypeToken.getType());\n            return new InMemorySubwayStorage(storage.entrySet().stream()\n\
    \                    .collect(Collectors.toMap(Map.Entry::getKey, e -> mapToDeque(e.getValue()))));\n\
    \        }\n    }\n\n    static Deque<Station> mapToDeque(final Map<String, Station>\
    \ map) {\n        return map.entrySet()\n                .stream()\n         \
    \       .sorted(Comparator.comparingInt(e -> Integer.parseInt(e.getKey())))\n\
    \                .map(Map.Entry::getValue)\n                .collect(Collectors.toCollection(ArrayDeque::new));\n\
    \    }\n\n    void connect(Transfer station1, Transfer station2);\n}\n"
  learner_created: true
- name: src/metro/commands/StorageCommandFactory.java
  visible: true
  text: |
    package metro.commands;

    public interface StorageCommandFactory {
        StorageCommand get();

        static StorageCommand fromCommand(final String cmd) {
            return new StorageCommandFactoryImpl(ConsoleCommand.parse(cmd))
                    .get();
        }
    }
  learner_created: true
- name: src/metro/model/Transfer.java
  visible: true
  text: |
    package metro.model;

    public class Transfer {
        private String line;

        public Transfer(String line, String station) {
            this.line = line;
            this.station = station;
        }

        private String station;

        public String getLine() {
            return line;
        }

        public void setLine(String line) {
            this.line = line;
        }

        public String getStation() {
            return station;
        }

        public void setStation(String station) {
            this.station = station;
        }
    }
  learner_created: true
- name: src/metro/commands/StorageCommandFactoryImpl.java
  visible: true
  text: |
    package metro.commands;

    import metro.model.Transfer;

    import java.util.List;

    public class StorageCommandFactoryImpl implements StorageCommandFactory {
        private final ConsoleCommand command;

        public StorageCommandFactoryImpl(ConsoleCommand command) {
            this.command = command;
        }

        @Override
        public StorageCommand get() {
            final String type = command.getType();
            final List<String> args = command.getArgs();
            switch (type) {
                case "append":
                    return StorageCommands.append(args.get(0), args.get(1));
                case "add-head":
                    return StorageCommands.addHead(args.get(0), args.get(1));
                case "output":
                    return StorageCommands.output(args.get(0));
                case "remove":
                    return StorageCommands.remove(args.get(0), args.get(1));
                case "connect":
                    final Transfer st1 = new Transfer(args.get(0), args.get(1));
                    final Transfer st2 = new Transfer(args.get(2), args.get(3));
                    return new ConnectCommand(st1, st2);
                case "exit":
                    return StorageCommands.exit();
                default:
                    throw new IllegalStateException("Unsupported command : " + type);
            }
        }
    }
  learner_created: true
- name: src/metro/commands/ConsoleCommand.java
  visible: true
  text: |
    package metro.commands;


    import java.util.ArrayList;
    import java.util.Collections;
    import java.util.List;
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;

    public class ConsoleCommand {
        private static final Pattern NAME_PATTERN = Pattern.compile("/(\\S+)");
        private static final Pattern ARG_PATTERN = Pattern.compile("\\s*(\"([^\"]+)\"|(\\S+))\\s*");

        public List<String> getArgs() {
            return args;
        }

        private final String type;
        private final List<String> args;

        private ConsoleCommand(String type, List<String> args) {
            this.type = type;
            this.args = args;
        }

        public static ConsoleCommand parse(String cmd) {
            final Matcher nameMatcher = NAME_PATTERN.matcher(cmd);
            final String cmdName;
            final String argsPart;
            if (nameMatcher.find() && nameMatcher.start() == 0) {
                cmdName = nameMatcher.group(1);
                argsPart = cmd.substring(nameMatcher.end());
            } else {
                throw new IllegalStateException("Incorrect format of command. Command: " + cmd);
            }
            Matcher argMatcher = ARG_PATTERN.matcher(argsPart);
            List<String> args = new ArrayList<>();
            while (argMatcher.find()) {
                String group = argMatcher.group(2);
                final String value = group == null? argMatcher.group(3) : group;
                args.add(value);
            }
            return new ConsoleCommand(cmdName, Collections.unmodifiableList(args));
        }

        public String getType() {
            return type;
        }
    }
  learner_created: true
- name: src/metro/commands/StorageCommand.java
  visible: true
  text: |
    package metro.commands;

    import metro.storage.SubwayStorage;

    @FunctionalInterface
    public interface StorageCommand {

        void run(SubwayStorage storage);
    }
  learner_created: true
- name: src/metro/printer/StationsPrinter.java
  visible: true
  text: |
    package metro.printer;

    import metro.model.Station;
    import metro.model.Transfer;

    import java.util.ArrayDeque;
    import java.util.ArrayList;
    import java.util.Collections;
    import java.util.Deque;
    import java.util.Iterator;
    import java.util.LinkedList;
    import java.util.List;
    import java.util.stream.Collectors;

    class StationsPrinter implements Printer {
        public static final Station DEPOT = new Station("depot");
        private final List<Station> stations;

        public StationsPrinter(List<Station> stations) {
            final Deque<Station> deque = new ArrayDeque<>(stations);
            deque.addFirst(DEPOT);
            this.stations = Collections.unmodifiableList(new ArrayList<>(deque));
        }

        @Override
        public void print() {
            for (Station station : stations) {
                System.out.println(printStation(station));
            }
            System.out.println(printStation(DEPOT));
        }


        private String printStation(Station station) {
            if (station == null) {
                return null;
            }
            final StringBuilder sb = new StringBuilder(station.getName());
            final List<Transfer> transfer = station.getTransfer();
            if (transfer != null && !transfer.isEmpty()) {
                for (Iterator<Transfer> iterator = transfer.iterator(); iterator.hasNext(); ) {

                    Transfer t = iterator.next();
                    sb.append(" - ")
                            .append(t.getStation())
                            .append(" (")
                            .append(t.getLine())
                            .append(")");
                }
            }
            return sb.toString();
        }

    }
  learner_created: true
- name: src/metro/commands/ConnectCommand.java
  visible: true
  text: |
    package metro.commands;

    import metro.model.Transfer;
    import metro.storage.SubwayStorage;

    public class ConnectCommand implements StorageCommand {
        private final Transfer transfer1;
        private final Transfer transfer2;

        public ConnectCommand(Transfer transfer1, Transfer transfer2) {
            this.transfer1 = transfer1;
            this.transfer2 = transfer2;
        }

        @Override
        public void run(SubwayStorage storage) {
            storage.connect(transfer1, transfer2);
        }
    }
  learner_created: true
- name: src/metro/commands/StorageCommands.java
  visible: true
  text: |
    package metro.commands;

    import metro.printer.Printer;

    public class StorageCommands {

        private StorageCommands() {
        }

        static StorageCommand append(final String lineName, final String stationName) {
            return new AppendCommand(lineName, stationName);
        }

        static StorageCommand addHead(final String lineName, final String stationName) {
            return storage -> storage.addHead(lineName, stationName);
        }
        public static StorageCommand remove(final String lineName, final String stationName) {
            return storage -> storage.remove(lineName, stationName);
        }

        public static StorageCommand output(final String lineName) {
            return storage -> Printer.stations(storage.stationsByLine(lineName)).print();
        }

        public static StorageCommand exit() {
            return storage -> System.exit(0);
        }
    }
  learner_created: true
  - name: src/metro/ds/Graph.java
    visible: true
    learner_created: true
  - name: src/metro/ds/AdjacencyListsGraph.java
    visible: true
    learner_created: true
  - name: src/metro/ds/GraphUtils.java
    visible: true
    learner_created: true
  - name: src/metro/commands/RouteCommand.java
    visible: true
    learner_created: true
  - name: src/metro/printer/RouterPrinter.java
    visible: true
    learner_created: true
  - name: src/metro/model/StationVertex.java
    visible: true
    learner_created: true
  - name: src/metro/route/Route.java
    visible: true
    learner_created: true
  - name: src/metro/route/RoutePoint.java
    visible: true
    learner_created: true
  - name: src/metro/route/SimpleRoute.java
    visible: true
    learner_created: true
  - name: src/metro/route/RouteFinder.java
    visible: true
    learner_created: true
  - name: src/metro/route/SubwayRouteFinder.java
    visible: true
    learner_created: true
  - name: src/metro/route/ShortestRouteFinder.java
    visible: true
    learner_created: true
feedback_link: https://hyperskill.org/learn/step/10344#comment
status: Failed
feedback:
  message: |-
    Wrong answer in test #8

    Your program printed an incorrect number of stations in the route.
    Expected: 5 stations and 2 transitions. Output should be 9 lines.
    Your output: 8 lines

    Please find below the output of your program during this failed test.
    Note that the &#39;&gt;&#39; character indicates the beginning of the input line.

    ---

    Arguments: ./test/prague.json

    &gt; /route &quot;Linka C&quot; &quot;Vysehrad&quot; &quot;Linka B&quot; &quot;Namesti Republiky&quot;
    Vysehrad
    I.P.Pavlova
    Muzeum
    Hlavni nadrazi
    Florenc
    Transition to line Linka B
    Florenc
    Namesti Republiky
  time: Fri, 01 Apr 2022 18:13:45 UTC
record: -1
